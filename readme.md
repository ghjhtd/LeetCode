# 力扣刷题总结：
##1.数组部分：
###1.数组的遍历：
+ 三个数的最大乘积(628)：
记得**Arrays.sort()**这个函数的使用，该算法采用快速排序，时间复杂度O(nlogn).默认升序。
###2.统计数组中的元素:
+ 645:错误的集合：Java哈希表 HashMap.getOrDefault(Object key, V defaultValue) Java8新特性，如果哈希表中有这个Key则获取这个值，如果没有则初始化Key的值为defaultValue.
 c语言有一个贼强的数据结构开源库，uthash库,[开源地址点击这里](https://github.com/troydhanson/uthash)。
 + 41:缺失的第一个正数(请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。),这种类型的题有一种很巧妙的解决方法，就是将数组本身作为一种哈希表，以此题为例，其思路就是首先将数组中<0的数全部置为大于N
 的一个常数，然后遍历该数组，将 n>x>0的数对应序号的数组取反，另一种类型的此题解法是在对应数组的数字上加上数组长度，取出时
 取余，不过此法只适用于数组中的数字范围是0-nums.length。
 + 189:**旋转数组**:对于将数组向后或向前移动多少位的问题可以巧妙的将其看作对数组进行转置操作所得。
 + 498:**遍历数组**:对数组进行遍历时，需要仔细分步的考虑情况，特殊情况下可以使用一个额外的标志数组来
 表示某元素是否被访问过。
 + 48:**旋转图像**:对于数组旋转问题，当题目要求空间复杂度为O(1)时，有两种解决方式，一种是一个元素一个元素的进行移动，
 另一种方式是对将数组的旋转动作分解为转置操作，列如旋转操作可分解为先将其通过水平轴翻转，
 再根据主对角线翻转。
 + 303:**区域和检索**:计算数据的区域和的时候，可采用前缀和的方式。对于二维区域和问题，可分解为
 一维区域和问题进行解决，也可采用二维区域和的方式。
 
 ##2.字符串部分：
 ###字符串的反转：
 + 151:**翻转字符串里的单词**:对于字符串的分割问题，可以采用自己编写函数的方式，也可以采用自带的api，**要注意在字符串中，空白的字符好像有许多个**，
 自己编写函数的时候要注意。调用api时，**Arrays.asList(s.split("\\s+"))**表示将字符串按空白字符分割为数组。
 + 451:**字符串里的字符按照出现的频率降序排列：**此题用到了Collections.sort这个工具类，是用来对List类型进行排序的，
 以及java的Lambda 表达式，其示例为：(a, b) -> (int)map.get(b) - (int)map.get(a)；
 + 467:**环绕字符串中唯一的子字符串**:此题需要注意的地方在于**以某字符结尾的连续子串的长度，就等于以该字符结尾的相等子串的个数**
 ### 数字与字符串间转换
 + 8:**罗马数字转整数**：对于字符串的处理，可以采用状态机的概念，将对字符串的处理分为几个状态来进行处理比较方便。
### 子序列
 + 524:一种匹配子序列的代码，感觉写得比较简洁,双指针：
~~~java
while (i < t.length() && j < s.length()) {
                if (t.charAt(i) == s.charAt(j)) {
                    ++i;
                }
                ++j;
            }
~~~
### 高精度运算
+ 67 ：**二进制求和**：这题看题解get到一个点，Java中java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数：
```java
public String addBinary(String a, String b) {
        return new BigInteger(a, 2).add(new BigInteger(b, 2)).toString(2);
        }
```
+ **高精度运算**:306,逻辑比较麻烦，可以看作一道综合题。

### 字符串变换：
+ 68：**文本左右对齐**：有点麻烦，后面有时间可以再做一下

### 字符串匹配:
+ 28:**实现 strStr()**：此题采用Knuth-Morris-Pratt 算法较为适宜，偷懒直接调用API，有空实现一下。KMP 算法是一个快速查找匹配串的算法，它的作用其实就是本题问题：如何快速在「原字符串」中找到「匹配字符串」。
+ 686:**重复叠加字符串匹配**:此题也是KMP,tnnd还是得好好学一下

### 中心拓展法:
+ 647:回文子串:中心拓展法可以用来求取回文子串，没想到一遍过，哈哈哈

## 3.数与位
### 数字的位操作：
+ 564：**寻找最近的回文数**：情况有点复杂，可以锻炼下思维能力，cv了，有空可以再重新写写。
+ 233:**给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数**:hard题，自己写循环超时，官解偏数学推导一点。
+ 400：**第N位数字**:此题暴力求解超时了，这题更像一道找规律的题，有点麻烦，难想到，有时间可以再推导一下
+ 29:**两数相除：**此题通过二分查找和二进制乘法来解决，值得一看，今日看不动了，有空仔细看看
 ### 快速幂：
+ 372：**超级次方：**此题设计幂运算，没仔细看，比较重要，建议再刷几次。

## 4.栈与递归：
### 用栈访问最后若干元素
+ **388：文件的最长绝对路径：**此题较为繁琐，有空可以做做。
### 栈与括号匹配:
+ 591:**标签验证器**：hard,没做了，类似代码检测器，有空可以写一下，感觉有点复杂。
### 递归：
 
## 6.哈希表
###哈希表的查找、插入及删除
+ 166：**分数到小数：**此题较为繁琐，需要注意使用Long类型，考虑的因素较多，除法判断是否循环小数可以用哈希表，每次除法的余数如果和之前的一样就代表循环了。
+ 466:**统计重复个数：**不愧是hard题，自己写的题解直接超时了，最后直接cv的，有空可以看看，这题还是有点意思的
+ ArrayList.toArray()说明：
```java
        // 当list中的数据类型都一致时可以将list转化为数组
        Object arr2[] = list.toArray();
        System.out.println("从list转换成的对象数组长度为：" + arr2.length); // 输出：从list转换成的对象数组长度为：4
        // 在转化为其它类型的数组时需要强制类型转换，并且，要使用带参数的toArray方法，参数为对象数组.
        // 将list中的内容放入参数数组中，当参数数组的长度小于list的元素个数时，会自动扩充数组的长度以适应list的长度
        Double arr3[] = list.toArray(new Double[0]);
        System.out.println("从list转换成的字符串数组长度为：" + arr3.length); // 输出：从list转换成的字符串数组长度为：4
        print(arr3); // 输出：1.23 4.57 2.38 4.598
        // 分配一个长度与list的长度相等的字符串数组
        Double[] arr4 = list.toArray(new Double[list.size()]);
        System.out.println("从list转换成的字符串数组长度为：" + arr4.length); // 输出：从list转换成的字符串数组长度为：4
        print(arr4); // 输出： 1.23 4.57 2.38 4.598
```
+ 560:**和为k的子数组：**对于此题，求数组中某一段的值，可以采用前缀表的形式，将前缀表用哈希表存储起来可以进行进一步的优化。
+ 525:**连续数组：**求0 和 1 的数量相同的连续数组时，可把0看作-1，然后求和为0的连续数组，具体求时，可用哈希表，把每次前缀和的结果放入进去，如果结果已经在里面包含，则可以进行计算。
+ 15:**三数之和**：比较重要，比较常见
+ 18：**四数之和**：三数之和升级版，逻辑比较复杂。没仔细看题解，copy的
+ 167：**两数之和 II - 输入有序数组**：

## 7.贪心算法
###哈数组与贪心算法
+ 406：**根据身高重建队列**：
+ 517: **超级洗衣机**：hard题，此题代码量虽少，但没咋搞懂，值得有空好好推敲推敲
+ 420: **强密码检验器：** 此题思维难度极高，做不出来，题解看不太懂，以后后空或者有心情的时候好好研究一下。
###子数组与贪心算法
+ 53: **最大子序和**：此题的分治解法好像挺巧妙地，还没细看。

### 单调栈法:
+ 84: **柱状图中最大的矩形**:比较经典。此题采用单调栈法求解，对于柱状图中最大矩形的问题，可先考虑暴力解法，以每一个位置为中心，向两边遍历找到以当前位置为中心的矩形的宽度，然后进行比较。单调栈法采用单调栈存储下标
+ 85： **最大矩形**：在一个二维矩阵中求最大矩形面积，可将其转化为一行一行的求柱状图中的最大矩形


## 8.双指针法
###头尾指针
+ 15： **三数之和**:对于求数组中三个数的和的唯一序列的问题，可以先用排序进行降重，然后固定第一个数，剩下的两个数采用双指针法，结果太大则右指针左移。
+ 11: **盛最多水的容器**:当固定较小一端的指针时，无论如何移动另一端的指针，得到的面积都比当前小，因此可以移动较小一端的指针，减小问题的规模。
+ 42: **接雨水**：此题有动态规划，单调栈，双指针三种解法，比较经典，刚开始时思路不清晰。
###同向双指针、滑动窗口
+ 424: **替换后的最长重复字符**:此题采用滑动窗口和双指针的解法，很是巧妙，需要重点看一下。
+ 76: **最小覆盖子串**：此题也是采用滑动窗口和双指针的解法，但比较有趣的一点就是采用了一个distance变量来表示窗口中和子串相同的字符的个数，可以用来表示两个子串的相似程度。
+ 30. **串联所有单词的子串**:没看题解写出来的一道Hard，有一些比较细节的地方需要注意
###分段双指针
+ 160: **相交链表**:这题看起来很简单，但双指针的解法很巧妙，很难想到，主要思想就是，A，B两个指针遍历A+B个次数后，一定会重合，且在这个过程中，指向的同一个点会重合

###快慢指针 ->可以用来寻找链表的中点，以及用来寻找循环交点
+ 142: **环形链表 II**:对于双指针求出环形交点的思想比较巧妙
+ 143: **重排链表**:此题的双指针解法十分巧妙和精彩，自己写的时候用的一种空间复杂度比较高的方法，双指针解法中用快慢指针寻找链表中点 + 链表逆序 + 合并链表
+ 457: **环形数组是否存在循环**:此题很有趣，用快慢指针来寻找环，代码理解掌握不深，建议再看几遍，熟练掌握
+ 287: **寻找重复数**:真是巧妙，当数组中有两个重复数时，可看作有两个数同时指向另一个数，数组中必存在环，而环就可以用快慢指针来求解。

## 9.树
###树与递归
+ 222: **完全二叉树的节点个数**:对于完全二叉树的计数，可以只用统计层数和最后一层的节点个数，最后一层的节点可以采用二分查找的方法遍历，最后一层节点可以采用二进制数来查找。
+ 437: **路径总和 III**:对于求二叉树中的路径总和的问题，可以采用前缀表加递归的方式，前缀表可以采用哈希表，通过求哈希表中某一个元素的个数，求出此条路径上所有的结果，注意初始时要在哈希表中加入一个值为0的节点
+ 